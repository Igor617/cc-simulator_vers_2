<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2D Симулятор колл-центра — цифровой двойник</title>
<style>
  :root{
    --bg:#0c1117; --panel:#111827; --muted:#334155; --ink:#e5e7eb; --ink2:#94a3b8;
    --accent:#22c55e; --accent2:#16a34a; --danger:#ef4444; --wait:#f59e0b; --blue:#3b82f6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:flex;flex-direction:column;gap:10px;max-width:1200px;margin:0 auto;padding:14px}
  h1{font-size:18px;margin:0 0 6px 0;font-weight:600;letter-spacing:.2px}
  /* Controls layout: inputs in responsive grid + one full-width actions row to prevent overlap */
  .controls{display:grid;gap:10px;background:var(--panel);padding:12px;border-radius:12px}
  .inputs{display:grid;gap:8px;grid-template-columns:repeat(auto-fit,minmax(170px,1fr))}
  .controls label{display:block;font-size:12px;color:var(--ink2);margin-bottom:4px}
  .controls input{width:100%;padding:6px 8px;border-radius:9px;border:1px solid #1f2937;background:#0b1220;color:var(--ink)}
  .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:4px}
  .btn{cursor:pointer;border:1px solid #1f2937;background:#0b1220;color:var(--ink);padding:10px 14px;border-radius:14px;text-align:center;user-select:none;min-width:112px}
  .btn:hover{background:#0e172a}
  .btn.primary{background:var(--accent);border-color:var(--accent2);color:#052e12;font-weight:700}
  .btn.stop{background:#7f1d1d;border-color:#991b1b}
  .btn.ghost{background:transparent;border-color:#334155}
  .speed{display:flex;gap:8px;flex-wrap:wrap}
  .speed .chip{padding:8px 12px;border:1px solid #1e3a8a;background:#172554;border-radius:12px;min-width:44px;text-align:center;cursor:pointer;user-select:none}
  .speed .chip.active{background:#3b82f6;border-color:#2563eb;color:#021025;font-weight:700}
  .sim-row{display:grid;grid-template-columns:1fr;gap:8px}
  .stage{background:var(--panel);border-radius:14px;padding:10px;position:relative;overflow:hidden}
  .legend{position:absolute;right:10px;top:10px;font-size:12px;color:var(--ink2)}
  .legend span{display:inline-flex;align-items:center;gap:6px;margin-left:12px}
  .dot{width:10px;height:10px;border-radius:50%}
  .q{background:var(--danger)}
  .s{background:var(--blue)}
  .a{background:var(--wait)}
  svg{width:100%;height:520px;border-radius:10px;display:block;background:#0b1220}
  .title{position:absolute;left:14px;top:10px;font-size:13px;color:#cbd5e1}
  .charts{display:none;grid-template-columns:1fr;gap:12px}
  .chart{background:var(--panel);border-radius:12px;padding:10px;position:relative}
  canvas{width:100%;height:160px;background:#0b1220;border-radius:8px;display:block}
  .bar{height:66px}
  .subttl{margin:0 0 6px 0;color:#cbd5e1;font-size:13px}
  .footnote{color:#64748b;font-size:12px;margin-top:4px}
  .tooltip{position:absolute;pointer-events:none;background:#0b1220;border:1px solid #334155;border-radius:10px;color:#e2e8f0;padding:8px 10px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:5;white-space:nowrap}
  .cross{position:absolute;pointer-events:none;border-left:1px dashed #334155;border-bottom:1px dashed #334155;opacity:.8}
</style>
</head>
<body>
<div class="wrap">
  <h1>2D Симулятор колл-центра (цифровой двойник)</h1>
  <div class="controls" id="controls">
    <div class="inputs">
      <div>
        <label>Входящие звонки в час (λ)</label>
        <input type="number" id="inpLambda" value="360" min="0" step="1">
      </div>
      <div>
        <label>Средняя длительность контакта, сек (AHT)</label>
        <input type="number" id="inpAHT" value="540" min="1" step="1">
      </div>
      <div>
        <label>Пост-обработка, сек (ACW)</label>
        <input type="number" id="inpACW" value="60" min="0" step="1">
      </div>
      <div>
        <label>Целевой SLA, % (в пределах T)</label>
        <input type="number" id="inpSLA" value="80" min="1" max="100" step="1">
      </div>
      <div>
        <label>Порог ожидания T, сек</label>
        <input type="number" id="inpThresh" value="20" min="0" step="1">
      </div>
      <div>
        <label>Макс. загруженность, %</label>
        <input type="number" id="inpOccMax" value="85" min="10" max="100" step="1">
      </div>
      <div>
        <label>Шринкаж, %</label>
        <input type="number" id="inpShrink" value="20" min="0" max="90" step="1">
      </div>
      <div>
        <label>Количество сотрудников (N)</label>
        <input type="number" id="inpN" value="12" min="0" step="1">
      </div>
    </div>
    <div class="actions">
      <div class="btn primary" id="btnStart">Запустить ▶</div>
      <div class="btn stop" id="btnStop">Остановить ■</div>
      <div class="btn ghost" id="btnReset">Сброс</div>
      <div class="speed" id="speed">
        <div class="chip active" data-speed="1">x1</div>
        <div class="chip" data-speed="2">x2</div>
        <div class="chip" data-speed="4">x4</div>
        <div class="chip" data-speed="8">x8</div>
      </div>
    </div>
    <div style="color:#94a3b8;font-size:12px">
      База времени: 1 сим-час = 1 реальная минута. Кнопки x2/x4/x8 ускоряют симуляцию кратно.
    </div>
  </div>

  <div class="sim-row">
    <div class="stage">
      <div class="title">Визуал области симуляции</div>
      <div class="legend">
        <span><i class="dot q"></i>Очередь</span>
        <span><i class="dot s"></i>Разговор</span>
        <span><i class="dot a"></i>Пост-обработка</span>
      </div>
      <svg id="sim" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet">
        <g id="gSource">
          <circle cx="70" cy="260" r="44" fill="none" stroke="#22c55e" stroke-width="4"/>
          <text id="txtSource" x="70" y="265" text-anchor="middle" fill="#e2e8f0" font-size="14">вход</text>
          <text id="txtLambda" x="70" y="290" text-anchor="middle" fill="#94a3b8" font-size="12">λ=360/ч</text>
        </g>

        <g id="gQueue">
          <rect x="130" y="40" width="300" height="440" rx="8" fill="#121b26" stroke="#245" stroke-width="3"/>
          <text id="labelQueue" x="140" y="30" fill="#cbd5e1" font-size="14">В очереди: 0</text>
        </g>

        <g id="gService">
          <rect x="450" y="40" width="400" height="440" rx="8" fill="#0f2314" stroke="#256a3f" stroke-width="3"/>
          <text id="labelService" x="460" y="30" fill="#cbd5e1" font-size="14">В работе: 0 / 0</text>
        </g>

        <g id="gACW">
          <rect x="870" y="40" width="220" height="440" rx="8" fill="#221a0a" stroke="#a16207" stroke-width="3"/>
          <text id="labelACW" x="880" y="30" fill="#cbd5e1" font-size="14">Пост-обработка: 0</text>
        </g>

        <g id="gDone">
          <circle cx="1130" cy="260" r="44" fill="none" stroke="#22c55e" stroke-width="4"/>
          <text id="txtDone" x="1130" y="258" text-anchor="middle" fill="#e2e8f0" font-size="14">готово</text>
          <text id="txtDoneNum" x="1130" y="290" text-anchor="middle" fill="#94a3b8" font-size="12">0</text>
        </g>
      </svg>
    </div>
  </div>

  <div class="charts" id="charts">
    <div class="chart" id="chart1">
      <p class="subttl">Кол-во клиентов на линиях <span style="color:#64748b">/ чел.</span></p>
      <canvas id="chClients" height="160"></canvas>
      <div class="footnote">Стек: очередь • разговор • пост-обработка. Ось X — <b>час</b>.</div>
    </div>
    <div class="chart" id="chart2">
      <p class="subttl">Суммарная занятость сотрудников <span style="color:#64748b">/ %</span></p>
      <canvas id="chOccBar" class="bar" height="66"></canvas>
      <div class="footnote">Активные (учёт шринкажа) и средняя занятость занятых.</div>
    </div>
    <div class="chart" id="chart3">
      <p class="subttl">Кол-во работающих сотрудников <span style="color:#64748b">/ чел.</span></p>
      <canvas id="chStaff" height="160"></canvas>
    </div>
    <div class="chart" id="chart4">
      <p class="subttl">Среднее время обслуживания <span style="color:#64748b">/ минут</span></p>
      <canvas id="chAHT" height="160"></canvas>
    </div>
    <div class="chart" id="chart5">
      <p class="subttl">Среднее время в очереди <span style="color:#64748b">/ минут</span></p>
      <canvas id="chWait" height="160"></canvas>
    </div>
  </div>
</div>

<script>
(function(){
  // ------- Helpers
  const $ = s=>document.querySelector(s);
  const svgns = "http://www.w3.org/2000/svg";
  const rndExp = mean => -mean * Math.log(1-Math.random());
  function clamp(v,mi,ma){return Math.max(mi,Math.min(ma,v));}
  function pad2(n){return String(n).padStart(2,'0');}
  function fmtHM(secs){const h=Math.floor(secs/3600);const m=Math.floor((secs%3600)/60);return pad2(h)+':'+pad2(m);}

  // ------- State
  let running=false, speedMul=1;
  const baseScale = 60; // 1 sim hour = 1 real minute => 60 sim seconds per 1 real second
  let simT=0, nextArrival=0, lastTs=0;
  const dots = new Set();
  let idSeq=1;

  let params = {
    lambda: 360, // per hour
    aht: 540, // secs
    acw: 60, // secs
    sla: 80,
    thr: 20,
    occMax: 85,
    shrink: 20,
    N: 12
  };

  let staff = []; // {id, state:'idle'|'busy'|'acw'|'break', el:group, x,y, busyUntil, acwUntil}
  let NActive = 0;

  // Metrics logging (each sim minute)
  let logEvery = 60; // sim seconds
  let nextLogAt = logEvery;
  const logs = {
    t: [],
    q: [],
    talk: [],
    acw: [],
    staffActive: [],
    occ: [],
    ahtMin: [],
    waitMin: []
  };
  const tmpMinute = {finishedDur:[], waitDur:[], busyAgentsTime:0, activeAgentsTime:0};

  // ------- SVG elements/areas
  const svg = $('#sim');
  const gService = $('#gService');
  const labelQueue = $('#labelQueue');
  const labelService = $('#labelService');
  const labelACW = $('#labelACW');
  const txtLambda = $('#txtLambda');
  const txtDoneNum = $('#txtDoneNum');

  const areas = {
    queue: {x:130,y:40,w:300,h:440, color:'#ef4444'},
    service: {x:450,y:40,w:400,h:440, color:'#3b82f6'},
    acw: {x:870,y:40,w:220,h:440, color:'#f59e0b'}
  };

  let doneCount=0;

  // ------- Build staff UI
  function buildStaff(){
    Array.from(gService.querySelectorAll('.agent')).forEach(n=>n.remove());
    staff.length = 0;

    const N = params.N|0;
    const cols = Math.min(8, Math.max(3, Math.ceil(Math.sqrt(Math.max(1,N)))));
    const rows = Math.ceil(Math.max(1,N)/cols);
    const pad = 14;
    const cellW = (areas.service.w - pad*2) / cols;
    const cellH = (areas.service.h - pad*2) / rows;

    for(let i=0;i<N;i++){
      const c = i%cols, rrow = Math.floor(i/cols);
      const x = areas.service.x + pad + c*cellW + cellW*0.5;
      const y = areas.service.y + pad + rrow*cellH + cellH*0.5;

      const g = document.createElementNS(svgns,'g');
      g.classList.add('agent');
      const circle = document.createElementNS(svgns,'circle');
      circle.setAttribute('cx',x); circle.setAttribute('cy',y);
      circle.setAttribute('r',16);
      circle.setAttribute('fill','#0b1220');
      circle.setAttribute('stroke','#16a34a'); circle.setAttribute('stroke-width','2');
      g.appendChild(circle);

      const badge = document.createElementNS(svgns,'circle');
      badge.setAttribute('cx',x+11); badge.setAttribute('cy',y+13);
      badge.setAttribute('r',5);
      badge.setAttribute('fill','#0b1220'); badge.setAttribute('stroke','#1f2937');
      g.appendChild(badge);

      gService.appendChild(g);
      staff.push({id:i+1,state:'idle',el:g,x,y,busyUntil:0,acwUntil:0});
    }

    NActive = Math.max(0, Math.round(N * (1 - params.shrink/100)));
    staff.forEach((ag,i)=>{
      if(i < NActive) { ag.state='idle'; ag.el.style.opacity = 1; }
      else { ag.state='break'; ag.el.style.opacity = .25; }
    });
    updateServiceLabel();
  }

  function updateServiceLabel(){
    const busy = staff.filter(s=>s.state==='busy').length;
    labelService.textContent = `В работе: ${busy} / ${params.N} (активно: ${NActive})`;
  }

  function setParamsFromInputs(){
    params.lambda = +$('#inpLambda').value;
    params.aht = clamp(+$('#inpAHT').value,1,7200);
    params.acw = clamp(+$('#inpACW').value,0,3600);
    params.sla = clamp(+$('#inpSLA').value,1,100);
    params.thr = clamp(+$('#inpThresh').value,0,600);
    params.occMax = clamp(+$('#inpOccMax').value,1,100);
    params.shrink = clamp(+$('#inpShrink').value,0,90);
    params.N = Math.max(0, +$('#inpN').value|0);
    txtLambda.textContent = `λ=${params.lambda}/ч`;
    buildStaff();
  }

  // ------- Dots (customers)
  function mkDot(x,y,color){
    const c = document.createElementNS(svgns,'circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',5); c.setAttribute('fill',color);
    svg.appendChild(c); return c;
  }

  function spawnToQueue(){
    const sx = 70, sy = 260;
    const dx = areas.queue.x + 10 + Math.random()*(areas.queue.w-20);
    const dy = areas.queue.y + 10 + Math.random()*(areas.queue.h-20);
    const el = mkDot(sx,sy,areas.queue.color);
    const o = { id:idSeq++, el, state:'toQueue', x:sx, y:sy, target:{x:dx,y:dy},
      createdAt:simT, enterQueueAt:0, enterServiceAt:0, leaveServiceAt:0, enterACWAt:0 };
    dots.add(o);
  }

  function tryAssign(){
    const waiting = [...dots].find(d=>d.state==='inQueue');
    if(!waiting) return false;
    const agent = staff.find(a=>a.state==='idle');
    if(!agent) return false;

    waiting.state='toService';
    waiting.target = {x:agent.x, y:agent.y};
    waiting.el.setAttribute('fill',areas.service.color);
    waiting.assigned = agent;

    agent.state='busy';
    agent.busyUntil = simT + Math.max(1, rndExp(params.aht));
    updateServiceLabel();
    return true;
  }

  function minuteLog(){
    logs.t.push(simT);
    const q = [...dots].filter(d=>d.state==='inQueue').length;
    const talk = staff.filter(a=>a.state==='busy').length;
    const acw = [...dots].filter(d=>d.state==='inACW' || d.state==='toACW').length;
    logs.q.push(q); logs.talk.push(talk); logs.acw.push(acw);
    logs.staffActive.push(NActive);
    const occ = tmpMinute.activeAgentsTime>0 ? (tmpMinute.busyAgentsTime/tmpMinute.activeAgentsTime) : 0;
    logs.occ.push(occ);
    const aht = tmpMinute.finishedDur.length ? (tmpMinute.finishedDur.reduce((a,b)=>a+b,0)/tmpMinute.finishedDur.length)/60 : (params.aht/60);
    logs.ahtMin.push(aht);
    const wait = tmpMinute.waitDur.length ? (tmpMinute.waitDur.reduce((a,b)=>a+b,0)/tmpMinute.waitDur.length)/60 : 0;
    logs.waitMin.push(wait);
    tmpMinute.finishedDur.length=0; tmpMinute.waitDur.length=0; tmpMinute.busyAgentsTime=0; tmpMinute.activeAgentsTime=0;
  }

  function updateCounters(){
    labelQueue.textContent = `В очереди: ${[...dots].filter(d=>d.state==='inQueue').length}`;
    labelACW.textContent = `Пост-обработка: ${[...dots].filter(d=>d.state==='inACW' || d.state==='toACW').length}`;
    updateServiceLabel();
    txtDoneNum.textContent = String(doneCount);
  }

  function step(realDt){
    if(!running) return;
    const simDt = realDt * baseScale * speedMul;
    const tEnd = simT + simDt;
    const ratePerSec = params.lambda/3600;
    while(nextArrival <= tEnd){
      spawnToQueue();
      nextArrival = (nextArrival||simT) + Math.max(1, rndExp(1/ratePerSec));
    }

    const moveSpeed = 120;
    dots.forEach(d=>{
      if(d.state==='toQueue' || d.state==='toService' || d.state==='toACW'){
        const dx = d.target.x - d.x, dy = d.target.y - d.y;
        const dist = Math.hypot(dx,dy);
        const stepLen = Math.min(dist, moveSpeed*simDt);
        if(dist<=1){
          if(d.state==='toQueue'){ d.state='inQueue'; d.enterQueueAt = simT; }
          else if(d.state==='toService'){ d.state='inService'; d.enterServiceAt = simT; tmpMinute.waitDur.push(d.enterServiceAt - d.enterQueueAt); }
          else if(d.state==='toACW'){ d.state='inACW'; d.enterACWAt = simT; }
          d.x = d.target.x; d.y = d.target.y;
        } else { d.x += (dx/dist)*stepLen; d.y += (dy/dist)*stepLen; }
        d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
      }
    });

    staff.forEach(ag=>{
      if(ag.state==='busy'){
        tmpMinute.busyAgentsTime += Math.min(simDt, Math.max(0, ag.busyUntil - simT));
        if(simT + simDt >= ag.busyUntil){
          const d = [...dots].find(o=>o.assigned===ag && o.state==='inService');
          if(d){
            d.state='toACW'; d.el.setAttribute('fill',areas.acw.color);
            d.target = { x: areas.acw.x + 10 + Math.random()*(areas.acw.w-20),
                         y: areas.acw.y + 10 + Math.random()*(areas.acw.h-20) };
            d.leaveServiceAt = ag.busyUntil;
            tmpMinute.finishedDur.push(d.leaveServiceAt - d.enterServiceAt);
          }
          ag.state='acw'; ag.acwUntil = ag.busyUntil + Math.max(1, rndExp(params.acw||1));
        }
      } else if(ag.state==='acw'){
        if(simT + simDt >= ag.acwUntil){
          const d = [...dots].find(o=>o.assigned===ag && (o.state==='inACW' || o.state==='toACW'));
          if(d){ d.el.remove(); dots.delete(d); doneCount++; }
          ag.state='idle';
        }
      }
      if(ag.state!=='break'){ tmpMinute.activeAgentsTime += simDt; }
    });

    while(tryAssign()){} // keep assigning

    if(tEnd >= nextLogAt){ minuteLog(); nextLogAt += logEvery; }
    simT = tEnd;
    updateCounters();
  }

  function loop(ts){
    if(!lastTs) lastTs = ts;
    const realDt = Math.min(0.1, (ts - lastTs)/1000);
    lastTs = ts;
    if(running) step(realDt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ------- Controls
  setParamsFromInputs();
  ['#inpLambda','#inpAHT','#inpACW','#inpSLA','#inpThresh','#inpOccMax','#inpShrink','#inpN'].forEach(id=>{
    $(id).addEventListener('change',()=>{ if(!running) setParamsFromInputs(); });
  });
  $('#speed').addEventListener('click',(e)=>{
    const btn = e.target.closest('.chip'); if(!btn) return;
    speedMul = +btn.dataset.speed;
    $('#speed').querySelectorAll('.chip').forEach(n=>n.classList.remove('active'));
    btn.classList.add('active');
  });
  $('#btnStart').addEventListener('click',()=>{
    if(running) return;
    Object.values(logs).forEach(a=>Array.isArray(a)&&a.splice(0,a.length));
    tmpMinute.finishedDur.length=tmpMinute.waitDur.length=0;
    tmpMinute.busyAgentsTime=tmpMinute.activeAgentsTime=0;
    nextLogAt = logEvery;
    dots.forEach(d=>d.el.remove()); dots.clear(); doneCount=0;
    $('#charts').style.display='none';
    simT=0; lastTs=0; nextArrival=0;
    running=true;
  });
  $('#btnStop').addEventListener('click',()=>{
    if(!running) return;
    running=false;
    drawCharts();
    $('#charts').style.display='grid';
  });
  $('#btnReset').addEventListener('click',()=>{
    running=false;
    dots.forEach(d=>d.el.remove()); dots.clear();
    doneCount=0; simT=0; nextArrival=0; lastTs=0;
    Object.values(logs).forEach(a=>Array.isArray(a)&&a.splice(0,a.length));
    $('#charts').style.display='none'; updateCounters();
  });

  // ------- Charting (axes + tooltip + crosshair)
  function niceStep(max, ticks){
    const raw = max/ticks;
    const mag = Math.pow(10, Math.floor(Math.log10(raw)));
    const norm = raw/mag;
    let step;
    if(norm<=1) step=1;
    else if(norm<=2) step=2;
    else if(norm<=5) step=5;
    else step=10;
    return step*mag;
  }
  function makeTooltip(container){
    const tt=document.createElement('div'); tt.className='tooltip'; tt.style.display='none'; container.appendChild(tt); return tt;
  }
  function makeCross(container){
    const cr=document.createElement('div'); cr.className='cross'; cr.style.display='none'; container.appendChild(cr); return cr;
  }
  function drawAxes(ctx, w, h, padL, padB, maxY, yUnit, tArr){
    ctx.clearRect(0,0,w,h);
    const plotW = w-padL-10, plotH = h-padB-16;
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth=1;
    const step = niceStep(maxY||1, 5);
    for(let y=0;y<=maxY;y+=step){
      const py = Math.round(h-padB - (y/(maxY||1))*plotH) + .5;
      ctx.beginPath(); ctx.moveTo(padL,py); ctx.lineTo(w-5,py); ctx.stroke();
      ctx.fillStyle='#94a3b8'; ctx.font='11px system-ui'; ctx.fillText(String(y), 6, py-2);
    }
    if(tArr && tArr.length>1){
      const len = tArr.length;
      const hours = Math.max(1, Math.floor((tArr[len-1])/3600));
      const per = Math.max(1, Math.round(len/(hours*4))); // ~4 ticks/hour
      for(let i=0;i<len;i+=per){
        const x = padL + (i/(len-1))*plotW;
        ctx.beginPath(); ctx.moveTo(x, h-padB); ctx.lineTo(x, h-padB+4); ctx.strokeStyle='#334155'; ctx.stroke();
        const lab = fmtHM(tArr[i]);
        ctx.fillStyle='#94a3b8'; ctx.fillText(lab, x-14, h-6);
      }
    }
    ctx.strokeStyle='#334155';
    ctx.beginPath(); ctx.moveTo(padL, h-padB); ctx.lineTo(w-5, h-padB); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, 6); ctx.lineTo(padL, h-padB); ctx.stroke();
    if(yUnit){ ctx.fillStyle='#94a3b8'; ctx.fillText(yUnit, 6, 12); }
    return {plotW, plotH};
  }
  function stackedMax(series){
    const len = series[0].length; let max=1;
    for(let i=0;i<len;i++){ let s=0; for(let k=0;k<series.length;k++) s += series[k][i]||0; if(s>max) max=s; }
    return max;
  }
  function lineMax(arr){ return Math.max(1, ...arr); }

  function drawStackedInteractive(canvas, series, colors, yUnit){
    const ctx = canvas.getContext('2d'); const w=canvas.width, h=canvas.height;
    const padL=42, padB=24;
    const maxY = stackedMax(series);
    const {plotW, plotH} = drawAxes(ctx,w,h,padL,padB,maxY,yUnit,logs.t);
    const len = series[0].length;
    const X = i => padL + (i/(len-1))*plotW;
    const Y = v => h - padB - (v/maxY)*plotH;
    const stacks = new Array(len).fill(0);
    series.forEach((arr, sIdx)=>{
      ctx.beginPath();
      for(let i=0;i<len;i++){
        stacks[i]+=arr[i]||0;
        const x=X(i), y=Y(stacks[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      for(let i=len-1;i>=0;i--){
        const base = stacks[i]-(arr[i]||0);
        const x=X(i), y=Y(base);
        ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fillStyle=colors[sIdx]; ctx.globalAlpha=.35; ctx.fill(); ctx.globalAlpha=1;
      ctx.strokeStyle=colors[sIdx]; ctx.lineWidth=1.5; ctx.stroke();
    });
    const cont = canvas.parentElement; cont.style.position='relative';
    const tt = cont.querySelector('.tooltip') || makeTooltip(cont);
    const cr = cont.querySelector('.cross') || makeCross(cont);
    canvas.onmousemove = (e)=>{
      if(len<2) return;
      const rect = canvas.getBoundingClientRect();
      const ox = e.clientX - rect.left - padL;
      if(ox<0 || ox>plotW){ tt.style.display='none'; cr.style.display='none'; return; }
      const i = Math.max(0, Math.min(len-1, Math.round(ox/plotW*(len-1))));
      const time = logs.t[i];
      let q=series[0][i]||0, talk=series[1][i]||0, acw=series[2][i]||0;
      tt.innerHTML = `<b>${fmtHM(time)}</b><br>Очередь: ${q}<br>Разговор: ${talk}<br>ACW: ${acw}<br>Итого: ${q+talk+acw}`;
      tt.style.display='block';
      const tx = e.clientX - rect.left + 12; const ty = e.clientY - rect.top - 10;
      tt.style.left = tx+'px'; tt.style.top = ty+'px';
      cr.style.display='block'; cr.style.left = (padL + (i/(len-1))*plotW)+'px'; cr.style.top = '0px'; cr.style.width='0px'; cr.style.height=(h-padB)+'px';
    };
    canvas.onmouseleave = ()=>{ tt.style.display='none'; const cr=canvas.parentElement.querySelector('.cross'); if(cr) cr.style.display='none'; };
  }

  function drawLineInteractive(canvas, data, color, yUnit){
    const ctx = canvas.getContext('2d'); const w=canvas.width, h=canvas.height;
    const padL=42, padB=24;
    const maxY = lineMax(data);
    const {plotW, plotH} = drawAxes(ctx,w,h,padL,padB,maxY,yUnit,logs.t);
    const len = data.length; const X=i=>padL + (i/(len-1))*plotW; const Y=v=>h-padB-(v/maxY)*plotH;
    ctx.strokeStyle=color; ctx.lineWidth=2;
    ctx.beginPath(); for(let i=0;i<len;i++){ const x=X(i), y=Y(data[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();
    const cont = canvas.parentElement; cont.style.position='relative';
    const tt = cont.querySelector('.tooltip') || makeTooltip(cont);
    const cr = cont.querySelector('.cross') || makeCross(cont);
    canvas.onmousemove = (e)=>{
      if(len<2) return;
      const rect = canvas.getBoundingClientRect();
      const ox = e.clientX - rect.left - padL;
      if(ox<0 || ox>plotW){ tt.style.display='none'; cr.style.display='none'; return; }
      const i = Math.max(0, Math.min(len-1, Math.round(ox/plotW*(len-1))));
      const time = logs.t[i]; const v = data[i];
      tt.innerHTML = `<b>${fmtHM(time)}</b><br>Значение: ${v.toFixed(2)}`;
      tt.style.display='block'; tt.style.left=(e.clientX-rect.left+12)+'px'; tt.style.top=(e.clientY-rect.top-10)+'px';
      cr.style.display='block'; cr.style.left=(padL + (i/(len-1))*plotW)+'px'; cr.style.top='0px'; cr.style.width='0px'; cr.style.height=(h-padB)+'px';
    };
    canvas.onmouseleave = ()=>{ tt.style.display='none'; const cr=canvas.parentElement.querySelector('.cross'); if(cr) cr.style.display='none'; };
  }

  function drawOccBar(canvas){
    const ctx=canvas.getContext('2d'); const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0b1220'; ctx.fillRect(0,0,w,h);
    const avgOcc = logs.occ.length ? (logs.occ.reduce((a,b)=>a+b,0)/logs.occ.length) : 0;
    const actShare = (NActive / Math.max(1, params.N));
    ctx.fillStyle='#1f2937'; ctx.fillRect(0,h*0.28,w,h*0.44);
    ctx.fillStyle='#16a34a'; ctx.fillRect(0,h*0.28,w*actShare,h*0.44);
    ctx.fillStyle='#22c55e'; ctx.fillRect(0,h*0.28,w*actShare*avgOcc,h*0.44);
    ctx.fillStyle='#e2e8f0'; ctx.font='13px system-ui';
    const txt = `Активно: ${(actShare*100).toFixed(0)}% • Средняя занятость: ${(avgOcc*100).toFixed(1)}% • Порог: ${params.occMax}%`;
    ctx.fillText(txt, 8, 16);
  }

  function drawCharts(){
    const c1 = $('#chClients');
    const c3 = $('#chStaff');
    const c4 = $('#chAHT');
    const c5 = $('#chWait');
    drawStackedInteractive(c1, [logs.q, logs.talk, logs.acw], ['#ef4444','#3b82f6','#f59e0b'], 'чел.');
    drawOccBar($('#chOccBar'));
    drawLineInteractive(c3, logs.staffActive, '#22c55e', 'чел.');
    drawLineInteractive(c4, logs.ahtMin, '#3b82f6', 'мин');
    drawLineInteractive(c5, logs.waitMin, '#f59e0b', 'мин');
  }

  // initial
  buildStaff(); updateCounters();
})();
</script>
</body>
</html>
