<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2D Симулятор колл‑центра — цифровой двойник</title>
<style>
  :root{
    --bg:#0c1117; --panel:#111827; --muted:#334155; --ink:#e5e7eb; --ink2:#94a3b8;
    --accent:#22c55e; --accent2:#16a34a; --danger:#ef4444; --wait:#f59e0b; --blue:#3b82f6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
  .wrap{display:flex;flex-direction:column;gap:10px;max-width:1200px;margin:0 auto;padding:14px;}
  h1{font-size:18px;margin:0 0 6px 0;font-weight:600;letter-spacing:.2px;}
  .controls{display:grid;grid-template-columns:repeat(8,minmax(120px,1fr));gap:8px;background:var(--panel);padding:10px;border-radius:12px;align-items:end}
  .controls label{display:block;font-size:12px;color:var(--ink2);margin-bottom:4px}
  .controls input{width:100%;padding:6px 8px;border-radius:9px;border:1px solid #1f2937;background:#0b1220;color:var(--ink)}
  .controls .btn{cursor:pointer;border:1px solid #1f2937;background:#0b1220;color:var(--ink);padding:8px 10px;border-radius:10px;text-align:center;user-select:none}
  .btn-row{display:flex;gap:8px}
  .btn:hover{background:#0e172a}
  .btn.primary{background:var(--accent);border-color:var(--accent2);color:#052e12;font-weight:700}
  .btn.warn{background:#172554;border-color:#1e3a8a}
  .btn.stop{background:#7f1d1d;border-color:#991b1b}
  .btn.ghost{background:transparent;border-color:#334155}
  .sim-row{display:grid;grid-template-columns:1fr;gap:8px}
  .stage{background:var(--panel);border-radius:14px;padding:10px;position:relative;overflow:hidden}
  .legend{position:absolute;right:10px;top:10px;font-size:12px;color:var(--ink2)}
  .legend span{display:inline-flex;align-items:center;gap:6px;margin-left:12px}
  .dot{width:10px;height:10px;border-radius:50%}
  .q{background:var(--danger)}
  .s{background:var(--blue)}
  .a{background:var(--wait)}
  svg{width:100%;height:520px;border-radius:10px;display:block;background:#0b1220}
  .title{position:absolute;left:14px;top:10px;font-size:13px;color:#cbd5e1}
  .charts{display:none;grid-template-columns:1fr;gap:12px}
  .chart{background:var(--panel);border-radius:12px;padding:8px}
  canvas{width:100%;height:120px;background:#0b1220;border-radius:8px}
  .bar{height:42px}
  .subttl{margin:0 0 6px 0;color:#cbd5e1;font-size:13px}
  .footnote{color:#64748b;font-size:12px;margin-top:4px}
  .counter{position:absolute;left:8px;top:8px;background:#0b1220;border:1px solid #1f2937;padding:4px 8px;border-radius:10px;color:#e2e8f0;font-size:12px}
  .counter.right{left:auto;right:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>2D Симулятор колл‑центра (цифровой двойник)</h1>
  <div class="controls" id="controls">
    <div>
      <label>Входящие звонки в час (λ)</label>
      <input type="number" id="inpLambda" value="360" min="0" step="1">
    </div>
    <div>
      <label>Средняя длительность контакта, сек (AHT)</label>
      <input type="number" id="inpAHT" value="540" min="1" step="1">
    </div>
    <div>
      <label>Пост‑обработка, сек (ACW)</label>
      <input type="number" id="inpACW" value="60" min="0" step="1">
    </div>
    <div>
      <label>Целевой SLA, % (в пределах T)</label>
      <input type="number" id="inpSLA" value="80" min="1" max="100" step="1">
    </div>
    <div>
      <label>Порог ожидания T, сек</label>
      <input type="number" id="inpThresh" value="20" min="0" step="1">
    </div>
    <div>
      <label>Макс. загруженность, %</label>
      <input type="number" id="inpOccMax" value="85" min="10" max="100" step="1">
    </div>
    <div>
      <label>Шринкаж, %</label>
      <input type="number" id="inpShrink" value="20" min="0" max="90" step="1">
    </div>
    <div>
      <label>Количество сотрудников (N)</label>
      <input type="number" id="inpN" value="12" min="0" step="1">
    </div>

    <div class="btn-row">
      <div class="btn primary" id="btnStart">Запустить ▶</div>
      <div class="btn stop" id="btnStop">Остановить ■</div>
      <div class="btn ghost" id="btnReset">Сброс</div>
    </div>
    <div class="btn-row">
      <div class="btn warn" data-speed="1">x1</div>
      <div class="btn warn" data-speed="2">x2</div>
      <div class="btn warn" data-speed="4">x4</div>
      <div class="btn warn" data-speed="8">x8</div>
    </div>
    <div style="grid-column:1/-1;color:#94a3b8;font-size:12px">
      База времени: 1 сим‑час = 1 реальная минута. Кнопки x2/x4/x8 ускоряют симуляцию кратно.
    </div>
  </div>

  <div class="sim-row">
    <div class="stage">
      <div class="title">Визуал области симуляции</div>
      <div class="legend">
        <span><i class="dot q"></i>Очередь</span>
        <span><i class="dot s"></i>Разговор</span>
        <span><i class="dot a"></i>Пост‑обработка</span>
      </div>
      <svg id="sim" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet">
        <!-- Left source circle -->
        <g id="gSource">
          <circle cx="70" cy="260" r="44" fill="none" stroke="#22c55e" stroke-width="4"/>
          <text id="txtSource" x="70" y="265" text-anchor="middle" fill="#e2e8f0" font-size="14">вход</text>
          <text id="txtLambda" x="70" y="290" text-anchor="middle" fill="#94a3b8" font-size="12">λ=360/ч</text>
        </g>

        <!-- Queue rectangle -->
        <g id="gQueue">
          <rect x="130" y="40" width="300" height="440" rx="8" fill="#123" stroke="#245" stroke-width="3"/>
          <text id="labelQueue" x="140" y="30" fill="#cbd5e1" font-size="14">В очереди: 0</text>
        </g>

        <!-- Service square with agents -->
        <g id="gService">
          <rect x="450" y="40" width="400" height="440" rx="8" fill="#10280f" stroke="#256a3f" stroke-width="3"/>
          <text id="labelService" x="460" y="30" fill="#cbd5e1" font-size="14">В работе: 0 / 0</text>
        </g>

        <!-- ACW rectangle -->
        <g id="gACW">
          <rect x="870" y="40" width="220" height="440" rx="8" fill="#241c0b" stroke="#a16207" stroke-width="3"/>
          <text id="labelACW" x="880" y="30" fill="#cbd5e1" font-size="14">Пост‑обработка: 0</text>
        </g>

        <!-- Right sink circle -->
        <g id="gDone">
          <circle cx="1130" cy="260" r="44" fill="none" stroke="#22c55e" stroke-width="4"/>
          <text id="txtDone" x="1130" y="258" text-anchor="middle" fill="#e2e8f0" font-size="14">готово</text>
          <text id="txtDoneNum" x="1130" y="290" text-anchor="middle" fill="#94a3b8" font-size="12">0</text>
        </g>
      </svg>
    </div>
  </div>

  <div class="charts" id="charts">
    <div class="chart">
      <p class="subttl">Кол‑во клиентов на линиях</p>
      <canvas id="chClients" height="120"></canvas>
      <div class="footnote">Стек: очередь • разговор • пост‑обработка</div>
    </div>
    <div class="chart">
      <p class="subttl">Суммарный график занятости сотрудников</p>
      <canvas id="chOccBar" class="bar" height="50"></canvas>
      <div class="footnote">Средняя занятость (busy/активные) и доля активных от общего штата с учётом шринкажа</div>
    </div>
    <div class="chart">
      <p class="subttl">Кол‑во работающих сотрудников</p>
      <canvas id="chStaff" height="120"></canvas>
    </div>
    <div class="chart">
      <p class="subttl">Среднее время обслуживания</p>
      <canvas id="chAHT" height="120"></canvas>
    </div>
    <div class="chart">
      <p class="subttl">Среднее время в очереди</p>
      <canvas id="chWait" height="120"></canvas>
    </div>
  </div>
</div>

<script>
(function(){
  // ------- Helpers
  const $ = s=>document.querySelector(s);
  const svgns = "http://www.w3.org/2000/svg";
  const rndExp = mean => -mean * Math.log(1-Math.random());
  function clamp(v,mi,ma){return Math.max(mi,Math.min(ma,v));}
  function fmtTimeSecs(secs){
    const h = Math.floor(secs/3600);
    const m = Math.floor((secs%3600)/60);
    return String(h).padStart(2,'0')+':'+String(m).padStart(2,'0');
  }

  // ------- State
  let running=false, speedMul=1;
  const baseScale = 60; // 1 sim hour = 1 real minute => 60 sim seconds per 1 real second
  let simT=0, nextArrival=0, lastTs=0;
  const dots = new Set();
  let idSeq=1;

  let params = {
    lambda: 360, // per hour
    aht: 540, // secs
    acw: 60, // secs
    sla: 80,
    thr: 20,
    occMax: 85,
    shrink: 20,
    N: 12
  };

  let staff = []; // {id, state:'idle'|'busy'|'acw'|'break', el:group, x,y, busyUntil, acwUntil}
  let NActive = 0;

  // Metrics logging (each sim minute)
  let logEvery = 60; // sim seconds
  let nextLogAt = logEvery;
  const logs = {
    t: [],
    q: [],
    talk: [],
    acw: [],
    staffActive: [],
    occ: [],
    ahtMin: [],
    waitMin: []
  };
  const tmpMinute = {finishedDur:[], waitDur:[], busyAgentsTime:0, activeAgentsTime:0};

  // ------- SVG elements/areas
  const svg = $('#sim');
  const gQueue = $('#gQueue');
  const gService = $('#gService');
  const gACW = $('#gACW');
  const labelQueue = $('#labelQueue');
  const labelService = $('#labelService');
  const labelACW = $('#labelACW');
  const txtLambda = $('#txtLambda');
  const txtDoneNum = $('#txtDoneNum');

  const areas = {
    queue: {x:130,y:40,w:300,h:440, color:'#ef4444'},
    service: {x:450,y:40,w:400,h:440, color:'#3b82f6'},
    acw: {x:870,y:40,w:220,h:440, color:'#f59e0b'}
  };

  let doneCount=0;

  // ------- Build staff UI
  function buildStaff(){
    // clear previous staff graphics (if any)
    Array.from(gService.querySelectorAll('.agent')).forEach(n=>n.remove());
    staff.length = 0;

    const N = params.N|0;
    const cols = Math.min(8, Math.max(3, Math.ceil(Math.sqrt(N))));
    const rows = Math.ceil(N/cols);
    const pad = 14;
    const r = 14;
    const cellW = (areas.service.w - pad*2) / cols;
    const cellH = (areas.service.h - pad*2) / rows;

    for(let i=0;i<N;i++){
      const c = i%cols, rrow = Math.floor(i/cols);
      const x = areas.service.x + pad + c*cellW + cellW*0.5;
      const y = areas.service.y + pad + rrow*cellH + cellH*0.5;

      const g = document.createElementNS(svgns,'g');
      g.classList.add('agent');
      const circle = document.createElementNS(svgns,'circle');
      circle.setAttribute('cx',x);
      circle.setAttribute('cy',y);
      circle.setAttribute('r',16);
      circle.setAttribute('fill','#0b1220');
      circle.setAttribute('stroke','#16a34a');
      circle.setAttribute('stroke-width','2');
      g.appendChild(circle);

      const badge = document.createElementNS(svgns,'circle');
      badge.setAttribute('cx',x+11);
      badge.setAttribute('cy',y+13);
      badge.setAttribute('r',5);
      badge.setAttribute('fill','#0b1220');
      badge.setAttribute('stroke','#1f2937');
      g.appendChild(badge);

      gService.appendChild(g);

      staff.push({id:i+1,state:'idle',el:g,x,y,busyUntil:0,acwUntil:0});
    }

    // determine active staff considering shrinkage
    NActive = Math.max(0, Math.round(N * (1 - params.shrink/100)));
    staff.forEach((ag,i)=>{
      if(i < NActive) {
        ag.state='idle';
        ag.el.style.opacity = 1;
      } else {
        ag.state='break';
        ag.el.style.opacity = .25; // visually dimmed
      }
    });
    updateServiceLabel();
  }

  function updateServiceLabel(){
    const busy = staff.filter(s=>s.state==='busy').length;
    labelService.textContent = `В работе: ${busy} / ${params.N} (активно: ${NActive})`;
  }

  function setParamsFromInputs(){
    params.lambda = +$('#inpLambda').value;
    params.aht = clamp(+$('#inpAHT').value,1, 7200);
    params.acw = clamp(+$('#inpACW').value,0, 3600);
    params.sla = clamp(+$('#inpSLA').value,1,100);
    params.thr = clamp(+$('#inpThresh').value,0, 600);
    params.occMax = clamp(+$('#inpOccMax').value,1,100);
    params.shrink = clamp(+$('#inpShrink').value,0,90);
    params.N = Math.max(0, +$('#inpN').value|0);
    txtLambda.textContent = `λ=${params.lambda}/ч`;
    buildStaff();
  }

  // ------- Dots (customers)
  function mkDot(x,y,color){
    const c = document.createElementNS(svgns,'circle');
    c.setAttribute('cx',x);
    c.setAttribute('cy',y);
    c.setAttribute('r',5);
    c.setAttribute('fill',color);
    svg.appendChild(c);
    return c;
  }

  function spawnToQueue(){
    // initial pos near source circle edge
    const sx = 70, sy = 260;
    const dx = areas.queue.x + 10 + Math.random()*(areas.queue.w-20);
    const dy = areas.queue.y + 10 + Math.random()*(areas.queue.h-20);

    const el = mkDot(sx,sy,areas.queue.color);
    const o = {
      id:idSeq++,
      el, state:'toQueue',
      x:sx, y:sy,
      target:{x:dx,y:dy},
      createdAt:simT,
      enterQueueAt:0, enterServiceAt:0, leaveServiceAt:0, enterACWAt:0
    };
    dots.add(o);
  }

  function tryAssign(){
    // find first waiting in queue
    const waiting = [...dots].find(d=>d.state==='inQueue');
    if(!waiting) return false;
    // find idle active agent
    const agent = staff.find(a=>a.state==='idle');
    if(!agent) return false;

    waiting.state='toService';
    waiting.target = {x:agent.x, y:agent.y};
    waiting.el.setAttribute('fill',areas.service.color);
    waiting.assigned = agent;

    agent.state='busy';
    agent.busyUntil = simT + Math.max(1, rndExp(params.aht));
    // For occupancy calc
    updateServiceLabel();
    return true;
  }

  function minuteLog(dtSim){
    // Record one point
    logs.t.push(simT);
    // counts
    const q = [...dots].filter(d=>d.state==='inQueue'||d.state==='toServiceQueue').length;
    const talk = staff.filter(a=>a.state==='busy').length;
    const acw = [...dots].filter(d=>d.state==='inACW' || d.state==='toACW').length;
    logs.q.push(q); logs.talk.push(talk); logs.acw.push(acw);
    logs.staffActive.push(NActive);
    // occupancy
    const occ = tmpMinute.activeAgentsTime>0 ? (tmpMinute.busyAgentsTime/tmpMinute.activeAgentsTime) : 0;
    logs.occ.push(occ);
    // averages
    const aht = tmpMinute.finishedDur.length ? (tmpMinute.finishedDur.reduce((a,b)=>a+b,0)/tmpMinute.finishedDur.length)/60 : (params.aht/60);
    logs.ahtMin.push(aht);
    const wait = tmpMinute.waitDur.length ? (tmpMinute.waitDur.reduce((a,b)=>a+b,0)/tmpMinute.waitDur.length)/60 : 0;
    logs.waitMin.push(wait);

    // reset minute buckets
    tmpMinute.finishedDur.length = 0;
    tmpMinute.waitDur.length = 0;
    tmpMinute.busyAgentsTime = 0;
    tmpMinute.activeAgentsTime = 0;
  }

  function updateCounters(){
    labelQueue.textContent = `В очереди: ${[...dots].filter(d=>d.state==='inQueue' || d.state==='toServiceQueue').length}`;
    labelACW.textContent = `Пост‑обработка: ${[...dots].filter(d=>d.state==='inACW' || d.state==='toACW').length}`;
    updateServiceLabel();
    txtDoneNum.textContent = String(doneCount);
  }

  function step(realDt){
    if(!running) return;
    const simDt = realDt * baseScale * speedMul;
    const tEnd = simT + simDt;
    // arrivals (Poisson) — schedule nextArrival in sim seconds
    const ratePerSec = params.lambda/3600;
    while(nextArrival <= tEnd){
      spawnToQueue();
      nextArrival = (nextArrival||simT) + Math.max(1, rndExp(1/ratePerSec));
    }

    // move dots
    const moveSpeed = 120; // px per sim second for transit
    dots.forEach(d=>{
      // Arrival into queue
      if(d.state==='toQueue'){
        const dx = d.target.x - d.x, dy = d.target.y - d.y;
        const dist = Math.hypot(dx,dy);
        const stepLen = Math.min(dist, moveSpeed*simDt);
        if(dist<=1){
          d.state='inQueue'; d.enterQueueAt = simT;
          d.x = d.target.x; d.y = d.target.y;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
        } else {
          d.x += (dx/dist)*stepLen; d.y += (dy/dist)*stepLen;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
        }
      }
      // Move to service (to agent)
      else if(d.state==='toService'){
        const dx = d.target.x - d.x, dy = d.target.y - d.y;
        const dist = Math.hypot(dx,dy);
        const stepLen = Math.min(dist, moveSpeed*simDt);
        if(dist<=1){
          d.state='inService'; d.enterServiceAt = simT;
          d.x = d.target.x; d.y = d.target.y;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
          // record wait duration
          tmpMinute.waitDur.push(d.enterServiceAt - d.enterQueueAt);
        } else {
          d.x += (dx/dist)*stepLen; d.y += (dy/dist)*stepLen;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
        }
      }
      // Move to ACW
      else if(d.state==='toACW'){
        const dx = d.target.x - d.x, dy = d.target.y - d.y;
        const dist = Math.hypot(dx,dy);
        const stepLen = Math.min(dist, moveSpeed*simDt);
        if(dist<=1){
          d.state='inACW'; d.enterACWAt = simT;
          d.x = d.target.x; d.y = d.target.y;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
        } else {
          d.x += (dx/dist)*stepLen; d.y += (dy/dist)*stepLen;
          d.el.setAttribute('cx',d.x); d.el.setAttribute('cy',d.y);
        }
      }
    });

    // service processing
    staff.forEach(ag=>{
      if(ag.state==='busy'){
        // busy time accounting
        tmpMinute.busyAgentsTime += Math.min(simDt, Math.max(0, ag.busyUntil - simT));
        if(simT + simDt >= ag.busyUntil){
          // conversation finished -> ACW
          const d = [...dots].find(o=>o.assigned===ag && o.state==='inService');
          if(d){
            d.state='toACW';
            d.el.setAttribute('fill',areas.acw.color);
            d.target = {
              x: areas.acw.x + 10 + Math.random()*(areas.acw.w-20),
              y: areas.acw.y + 10 + Math.random()*(areas.acw.h-20)
            };
            d.leaveServiceAt = ag.busyUntil;
            // record AHT
            tmpMinute.finishedDur.push(d.leaveServiceAt - d.enterServiceAt);
          }
          ag.state='acw';
          ag.acwUntil = ag.busyUntil + Math.max(1, rndExp(params.acw||1));
        }
      } else if(ag.state==='acw'){
        if(simT + simDt >= ag.acwUntil){
          // find the dot of this agent in ACW to complete
          const d = [...dots].find(o=>o.assigned===ag && (o.state==='inACW' || o.state==='toACW'));
          if(d){
            // remove dot (completed)
            d.el.remove(); dots.delete(d); doneCount++;
          }
          ag.state='idle';
        }
      }
      if(ag.state!=='break'){
        tmpMinute.activeAgentsTime += simDt;
      }
    });

    // assign while possible
    let assignedSomething = true;
    while(assignedSomething){
      assignedSomething = tryAssign();
    }

    // Logging per minute
    if(tEnd >= nextLogAt){
      minuteLog(tEnd - simT);
      nextLogAt += logEvery;
    }

    // update counters
    simT = tEnd;
    updateCounters();
  }

  function loop(ts){
    if(!lastTs) lastTs = ts;
    const realDt = Math.min(0.1, (ts - lastTs)/1000); // clamp to avoid huge steps
    lastTs = ts;
    if(running) step(realDt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ------- Controls
  setParamsFromInputs();
  ['#inpLambda','#inpAHT','#inpACW','#inpSLA','#inpThresh','#inpOccMax','#inpShrink','#inpN'].forEach(id=>{
    $(id).addEventListener('change',()=>{
      if(!running) setParamsFromInputs();
    });
  });

  document.querySelectorAll('[data-speed]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      speedMul = +btn.dataset.speed;
      document.querySelectorAll('[data-speed]').forEach(b=>b.classList.remove('primary'));
      btn.classList.add('primary');
    });
  });

  $('#btnStart').addEventListener('click',()=>{
    if(running) return;
    // reset logs
    logs.t.length=logs.q.length=logs.talk.length=logs.acw.length=logs.staffActive.length=logs.occ.length=logs.ahtMin.length=logs.waitMin.length=0;
    tmpMinute.finishedDur.length=tmpMinute.waitDur.length=0;
    tmpMinute.busyAgentsTime=tmpMinute.activeAgentsTime=0;
    nextLogAt = logEvery;
    // reset dots
    dots.forEach(d=>d.el.remove()); dots.clear(); doneCount=0;
    $('#charts').style.display='none';
    // time & arrivals
    simT=0; lastTs=0; nextArrival=0;
    running=true;
  });

  $('#btnStop').addEventListener('click',()=>{
    if(!running) return;
    running=false;
    drawCharts();
    $('#charts').style.display='grid';
  });

  $('#btnReset').addEventListener('click',()=>{
    running=false;
    dots.forEach(d=>d.el.remove()); dots.clear();
    doneCount=0; simT=0; nextArrival=0; lastTs=0;
    logs.t.length=logs.q.length=logs.talk.length=logs.acw.length=logs.staffActive.length=logs.occ.length=logs.ahtMin.length=logs.waitMin.length=0;
    $('#charts').style.display='none';
    updateCounters();
  });

  // ------- Charts (vanilla canvas)
  function drawStacked(ctx, w, h, series){
    ctx.clearRect(0,0,w,h);
    const len = series[0].length;
    if(!len) return;
    // find max stack
    let maxY = 0;
    for(let i=0;i<len;i++){
      let sum = 0;
      for(let s=0;s<series.length;s++) sum += series[s][i]||0;
      if(sum>maxY) maxY = sum;
    }
    maxY = Math.max(maxY, 1);

    const colors = ['#ef4444','#3b82f6','#f59e0b'];
    // draw grid
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth=1;
    for(let i=0;i<=5;i++){
      const y = h - (i*h/5);
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    // stacked areas
    for(let s=0;s<series.length;s++){
      ctx.beginPath();
      let yPrev=[];
      for(let i=0;i<len;i++){
        const x = (i/(len-1))*w;
        let base=0; for(let k=0;k<s;k++) base += series[k][i]||0;
        const v = base + (series[s][i]||0);
        const y = h - (v/maxY)*h;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
        yPrev.push(y);
      }
      // close to baseline of previous stacks
      for(let i=len-1;i>=0;i--){
        const x = (i/(len-1))*w;
        let base=0; for(let k=0;k<s;k++) base += series[k][i]||0;
        const yb = h - (base/maxY)*h;
        ctx.lineTo(x,yb);
      }
      ctx.closePath();
      ctx.fillStyle = colors[s];
      ctx.globalAlpha = 0.35;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = colors[s];
      ctx.stroke();
    }
  }

  function drawLine(ctx, w, h, data, color){
    ctx.clearRect(0,0,w,h);
    const len = data.length;
    if(!len) return;
    const maxY = Math.max(...data, 1);
    // grid
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth=1;
    for(let i=0;i<=5;i++){
      const y = h - (i*h/5);
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    // line
    ctx.strokeStyle = color; ctx.lineWidth=2;
    ctx.beginPath();
    data.forEach((v,i)=>{
      const x = (i/(len-1))*w;
      const y = h - (v/maxY)*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function drawOccBar(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    const avgOcc = logs.occ.length ? (logs.occ.reduce((a,b)=>a+b,0)/logs.occ.length) : 0;
    const actShare = (NActive / Math.max(1, params.N));
    // background
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,w,h);
    // total width baseline
    ctx.fillStyle = '#1f2937'; ctx.fillRect(0,h*0.2,w,h*0.6);
    // active share
    ctx.fillStyle = '#16a34a'; ctx.fillRect(0,h*0.2,w*actShare,h*0.6);
    // busy segment within active
    ctx.fillStyle = '#22c55e'; ctx.fillRect(0,h*0.2,w*actShare*avgOcc,h*0.6);
    // text
    ctx.fillStyle = '#e2e8f0'; ctx.font = '13px system-ui';
    const txt = `Активно: ${(actShare*100).toFixed(0)}% • Средняя занятость: ${(avgOcc*100).toFixed(1)}% • Порог: ${params.occMax}%`;
    ctx.fillText(txt, 8, 14);
  }

  function drawCharts(){
    const c1 = $('#chClients').getContext('2d');
    const c2 = $('#chOccBar').getContext('2d');
    const c3 = $('#chStaff').getContext('2d');
    const c4 = $('#chAHT').getContext('2d');
    const c5 = $('#chWait').getContext('2d');
    drawStacked(c1, c1.canvas.width, c1.canvas.height, [logs.q, logs.talk, logs.acw]);
    drawOccBar(c2, c2.canvas.width, c2.canvas.height);
    drawLine(c3, c3.canvas.width, c3.canvas.height, logs.staffActive, '#22c55e');
    drawLine(c4, c4.canvas.width, c4.canvas.height, logs.ahtMin, '#3b82f6');
    drawLine(c5, c5.canvas.width, c5.canvas.height, logs.waitMin, '#f59e0b');
  }

  // initial render
  buildStaff();
  updateCounters();
})();
</script>
</body>
</html>
